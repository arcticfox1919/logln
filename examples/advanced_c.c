// SPDX-License-Identifier: MIT
// Logln C Advanced Example
//
// Demonstrates: compression, encryption, custom format using C API
//
// Build:
//   cmake -B build -DLOGLN_BUILD_EXAMPLES=ON
//   cmake --build build --config Release

#include <logln/logln.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#define sleep_ms(ms) Sleep(ms)
#else
#include <unistd.h>
#define sleep_ms(ms) usleep((ms) * 1000)
#endif

// Server key pair (generated by loglnk)
static const char* SERVER_PRIVATE_KEY = "9a8d99b7e7981648a3700085f9276baba35f1b7e868d605a1056945d765f2322";
static const char* SERVER_PUBLIC_KEY  = "7280cab06a9e2651c429a895276487ab5fd62f8466f8f07f5e7490106e3bc1bb5e05477001275f1679d8a937ee6341b63ba285";

int main(void) {
    printf("=== Logln C Advanced Example ===\n\n");
    
    // ========================================================================
    // Method 1: Using config builder API (step by step)
    // ========================================================================
    
    logln_config_t config = logln_config_create();
    if (!config) {
        fprintf(stderr, "Failed to create config\n");
        return 1;
    }
    
    // Required settings
    logln_config_set_log_dir(config, "./logs");
    logln_config_set_name(config, "secure_c_app");
    
    // Logging settings
    logln_config_set_min_level(config, LOGLN_LEVEL_DEBUG);
    logln_config_set_mode(config, LOGLN_MODE_ASYNC);
    logln_config_set_console_output(config, true);
    
    // Enable compression (zstd level 3)
    logln_config_set_compression(config, LOGLN_COMPRESS_ZSTD, 3);
    
    // Enable encryption
    logln_config_set_pub_key(config, SERVER_PUBLIC_KEY);
    
    // Custom format pattern
    logln_config_set_format(config, "[{time6}][{Level:5}][{tid}][{tag}] {msg}{n}");
    
    // File management
    logln_config_set_max_file_size(config, 10 * 1024 * 1024);  // 10 MB
    logln_config_set_max_alive_duration(config, 7 * 24 * 60 * 60);  // 7 days
    
    // Validate configuration
    logln_result_t result = logln_config_validate(config);
    if (result != LOGLN_OK) {
        fprintf(stderr, "Config error: %s\n", logln_result_message(result));
        logln_config_destroy(config);
        return 1;
    }
    
    // Create logger
    logln_handle_t logger = logln_create(config);
    logln_config_destroy(config);  // Config can be destroyed after create
    
    if (!logger) {
        fprintf(stderr, "Failed to create logger\n");
        return 1;
    }
    
    printf("Logger created (method 1)\n\n");
    
    // ========================================================================
    // Method 2: Using struct initializer (single call)
    // ========================================================================
    
    /*
    logln_config_options_t opts = LOGLN_CONFIG_OPTIONS_INIT;
    opts.log_dir = "./logs";
    opts.name = "secure_c_app";
    opts.min_level = LOGLN_LEVEL_DEBUG;
    opts.compression = LOGLN_COMPRESS_ZSTD;
    opts.compression_level = 3;
    opts.format = "[{time6}][{Level:5}][{tid}][{tag}] {msg}{n}";
    opts.console_output = true;
    
    logln_handle_t logger = logln_create_with_options(&opts);
    */
    
    // ========================================================================
    // Write logs
    // ========================================================================
    
    LOGLN_VERBOSE(logger, "Main", "Verbose: trace info");
    LOGLN_DEBUG(logger, "Main", "Debug: application started");
    LOGLN_INFO(logger, "Main", "Info: processing %d items", 42);
    LOGLN_WARN(logger, "Network", "Warning: timeout after %d ms", 3000);
    LOGLN_ERROR(logger, "Database", "Error: %s", "query failed");
    
    // Simulate work
    printf("Simulating application activity...\n");
    for (int i = 1; i <= 5; ++i) {
        LOGLN_INFO(logger, "Worker", "Processing batch %d/5", i);
        LOGLN_DEBUG(logger, "Memory", "Heap: %d KB", i * 1024);
        sleep_ms(100);
    }
    
    // ========================================================================
    // Runtime control
    // ========================================================================
    
    // Change log level at runtime
    logln_set_level(logger, LOGLN_LEVEL_INFO);
    LOGLN_DEBUG(logger, "Main", "This will NOT be logged (level too low)");
    LOGLN_INFO(logger, "Main", "This WILL be logged");
    
    // Get current log file path
    char path[512];
    int len = logln_get_log_path(logger, path, sizeof(path));
    if (len > 0) {
        printf("\nCurrent log file: %s\n", path);
    }
    
    // ========================================================================
    // Cleanup
    // ========================================================================
    
    printf("\nFlushing logs...\n");
    logln_flush_sync(logger);
    logln_release(logger);
    
    printf("Done! Check ./logs/ for output files.\n");
    printf("\nTo decode:\n");
    printf("  loglnd ./logs/secure_c_app_*.blog\n");
    
    return 0;
}
