// SPDX-License-Identifier: MIT
// Logln C++ Advanced Example
//
// Demonstrates: compression, encryption, custom format, crash recovery
//
// Build:
//   cmake -B build -DLOGLN_BUILD_EXAMPLES=ON
//   cmake --build build --config Release
//
// Run:
//   ./build/Release/advanced_cpp
//
// Decode logs:
//   python examples/decode_logs.py

#include <logln/logln.h>
#include <iostream>
#include <thread>
#include <chrono>

// Server key pair (generated by loglnk)
// PRIVATE_KEY is kept secret on server for decryption
// PUBLIC_KEY is embedded in app for encryption
constexpr const char* SERVER_PRIVATE_KEY = "af3cd491a07442a660ac6ce5884ece8baa52e5437afa2ca7e9cb5589e0fe7e25";
constexpr const char* SERVER_PUBLIC_KEY  = "948f2886d96eceef15f56f03ad8d99c74bcaa6cfa753c2db684574e38e7f4440497c6ae54586115a6f4eb7f65679064b72e6752a3a287d39a694d751d7b94d94";

int main() {
    using namespace std::chrono_literals;
    
    std::cout << "=== Logln Advanced Example ===\n\n";
    
    // ========================================================================
    // Configuration with all features enabled
    // ========================================================================
    
    auto config = logln::ConfigBuilder()
        // Required: output directory
        .log_dir("./logs")
        
        // Logger name (used as file prefix: secure_app_20261010.blog)
        .name("secure_app")
        
        // Minimum log level
        .level(logln::Level::Debug)
        
        // Write mode: Async (default, recommended) or Sync
        .async()
        
        // Enable zstd compression (level 3 is optimal for logs)
        // Level 3: 84% compression at 89K ops/s
        .zstd(3)
        
        // Enable encryption with server public key
        // Logs can only be decrypted with the corresponding private key
        .encrypt(SERVER_PUBLIC_KEY)
        
        // Custom log format pattern
        // Supported tokens: {level}, {Level}, {time}, {time6}, {date},
        //                   {pid}, {tid}, {tid*}, {tag}, {file}, {path},
        //                   {line}, {func}, {msg}, {n}
        .format("[{time6}][{Level}][{tid}][{tag}] {msg}{n}")
        
        // Console output (useful for development)
        .console(true)
        
        // Log retention: delete files older than 7 days
        .max_alive(std::chrono::hours{24 * 7})
        
        // Flush interval: write buffered logs every 5 seconds
        .flush_interval(5s)
        
        // Max file size: 10MB per file (0 = no limit)
        .max_file_size(10 * 1024 * 1024)
        
        // Build and validate configuration
        .build();
    
    if (!config) {
        std::cerr << "Configuration error:\n";
        for (auto err : config.error()) {
            std::cerr << "  - " << logln::config_error_message(err) << "\n";
        }
        return 1;
    }
    
    // ========================================================================
    // Create logger
    // ========================================================================
    
    auto* logger = logln::Logger::create(*config);
    if (!logger) {
        std::cerr << "Failed to create logger\n";
        return 1;
    }
    
    std::cout << "Logger created successfully!\n";
    std::cout << "Log file: ./logs/secure_app_*.blog\n\n";
    
    // ========================================================================
    // Write logs at different levels
    // ========================================================================
    
    logger->verbose("Main", "Verbose: detailed trace information");
    logger->debug("Main", "Debug: application started, PID={}", getpid());
    logger->info("Main", "Info: processing {} items", 42);
    logger->warn("Network", "Warning: connection timeout after {} ms", 3000);
    logger->error("Database", "Error: query failed - {}", "table not found");
    
    // ========================================================================
    // Simulate application work with logging
    // ========================================================================
    
    std::cout << "Simulating application activity...\n";
    
    for (int i = 1; i <= 5; ++i) {
        logger->info("Worker", "Processing batch {}/5", i);
        
        // Simulate some work
        std::this_thread::sleep_for(100ms);
        
        // Log with different tags
        logger->debug("Memory", "Heap usage: {} KB", i * 1024);
        logger->debug("CPU", "Load: {}%", i * 15);
    }
    
    // ========================================================================
    // Log structured data
    // ========================================================================
    
    logger->info("Config", "Settings loaded: theme={}, locale={}, timeout={}",
                 "dark", "en-US", 30);
    
    logger->info("User", "Login successful: user_id={}, session={}", 
                 12345, "abc-def-ghi");
    
    // ========================================================================
    // Demonstrate crash recovery (mmap buffer)
    // ========================================================================
    
    // Even if the app crashes, logs in the mmap buffer will be preserved
    // The mmap file (*.mmap) can be decoded with loglnd
    
    logger->info("Main", "Application running normally");
    
    // To test crash recovery:
    // 1. Comment out logger->flush_sync() and logln::Logger::release_all()
    // 2. Add: *(int*)0 = 0;  // Force crash
    // 3. Run the program (it will crash)
    // 4. Check ./logs/ for *.mmap files
    // 5. Decode with: loglnd secure_app.mmap
    
    // ========================================================================
    // Cleanup
    // ========================================================================
    
    std::cout << "\nFlushing logs...\n";
    
    // Synchronous flush - waits for all buffered logs to be written
    logger->flush_sync();
    
    // Release all loggers (flushes and closes files)
    logln::Logger::release_all();
    
    std::cout << "Done! Check ./logs/ for output files.\n";
    std::cout << "\nTo decode the logs:\n";
    std::cout << "  loglnd ./logs/secure_app_*.blog\n";
    std::cout << "  # Or use the Python script:\n";
    std::cout << "  python examples/decode_logs.py ./logs\n";
    
    return 0;
}
